# 签名与验签示例代码

> ⚠️ 注意：
>
> 为了能让您更好地理解数据签名与验证的过程，我们提供了不同语言和框架的示例代码。但是这些示例代码并不是生产环境的最佳实践，您需要根据自己的实际情况进行调整。
>
> **为了您的数据安全，请不要直接将以下代码用于生产环境，以免造成不必要的损失。**


## Java

1. 签名算法

   ```java
   package com.example.springboot;
   
   import org.apache.commons.codec.digest.HmacAlgorithms;
   import org.apache.commons.codec.digest.HmacUtils;
   
   public class SignatureUtils {
       public static String sign(String secret, String contents) {
           return new HmacUtils(HmacAlgorithms.HMAC_SHA_256, secret).hmacHex(contents);
       }
   }
   ```
   
2. 验证签名示例

   > 以下示例代码基于 [Spring Boot][Spring Boot] 框架。
   >
   > **为了您的数据安全，请不要直接将以下代码用于生产环境，以免造成不必要的损失。**

   ```java
   package com.example.springboot.controller;
   
   import org.apache.commons.codec.digest.HmacAlgorithms;
   import org.apache.commons.codec.digest.HmacUtils;
   import org.slf4j.Logger;
   import org.slf4j.LoggerFactory;
   import org.springframework.http.HttpStatus;
   import org.springframework.web.bind.annotation.*;
   import org.springframework.web.server.ResponseStatusException;
   
   import jakarta.servlet.http.HttpServletRequest;
   
   import java.io.IOException;
   import java.util.*;
   import java.util.stream.Collectors;
   
   @RestController
   public class WebhookController {
   
       private static final Logger logger = LoggerFactory.getLogger(WebhookController.class);
   
       private static final String HEADER_TIMESTAMP_KEY = "X-Meowflow-Timestamp";
       private static final String HEADER_SIGNATURE_KEY = "X-Meowflow-Signature";
       private static final String QUERY_KEY_TIMESTAMP = "meowflow_timestamp";
       private static final String QUERY_KEY_SIGNATURE = "meowflow_signature";
       private static final long TIMESTAMP_EXPIRED_TIME = 300000; // 5 minutes
   
       /**
        * TODO:: need to replace with your app secret key from your Meowflow app
        */
       private final String secret = "your app secret";
   
       @RequestMapping(value = "/api/webhook", method = {RequestMethod.GET, RequestMethod.POST, RequestMethod.PUT, RequestMethod.PATCH, RequestMethod.DELETE})
       public Map<String, String> handle(HttpServletRequest request) {
           try {
               verifySignature(request);
           } catch (VerifySignatureException e) {
               throw new ResponseStatusException(HttpStatus.FORBIDDEN, e.getMessage());
           } catch (Exception e) {
               logger.error("Unknown error: {}", e.getMessage(), e);
               throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Internal server error");
           }
   
           //  TODO:: do something with the request here...
           logger.info("----------- received signature request -----------");
           return Map.of("message", "OK");
       }
   
       private void verifySignature(HttpServletRequest request) throws VerifySignatureException, IOException {
           Map<String, String> signatureFields = getSignatureFields(request);
           String timestamp = signatureFields.get(QUERY_KEY_TIMESTAMP);
           String signature = signatureFields.get(QUERY_KEY_SIGNATURE);
           checkSignatureBaseFields(timestamp, signature);
   
           String contents = buildSignatureContents(request, timestamp);
           if (!compareSignature(signature, contents)) {
               throw new VerifySignatureException("Signature verification failed");
           }
       }
   
       private Map<String, String> getSignatureFields(HttpServletRequest request) {
           String timestamp;
           String signature;
   
           if (isUrlDigest(request.getMethod())) {
               timestamp = Optional.ofNullable(request.getParameter(QUERY_KEY_TIMESTAMP))
                       .orElse(request.getHeader(HEADER_TIMESTAMP_KEY));
               signature = Optional.ofNullable(request.getParameter(QUERY_KEY_SIGNATURE))
                       .orElse(request.getHeader(HEADER_SIGNATURE_KEY));
           } else {
               timestamp = request.getHeader(HEADER_TIMESTAMP_KEY);
               signature = request.getHeader(HEADER_SIGNATURE_KEY);
           }
   
           return Map.of(
                   QUERY_KEY_TIMESTAMP, Optional.ofNullable(timestamp).orElse(""),
                   QUERY_KEY_SIGNATURE, Optional.ofNullable(signature).orElse("")
           );
       }
   
       private String buildSignatureContents(HttpServletRequest request, String timestamp) throws IOException {
           StringBuilder contents = new StringBuilder(request.getMethod())
                   .append(" ")
                   .append(Optional.ofNullable(request.getServerName())
                           .map(name -> {
                               int port = request.getServerPort();
                               boolean isNonStandardPort = (port != 80 && port != 443) ||
                                       (port == 80 && request.isSecure()) ||
                                       (port == 443 && !request.isSecure());
                               return isNonStandardPort ? name + ":" + port : name;
                           })
                           .orElse(""))
                   .append(request.getRequestURI());
   
           if (isUrlDigest(request.getMethod())) {
               String queryParams = buildUrlSignatureContent(request, timestamp);
               contents.append("?").append(queryParams);
           } else if (request.getContentLength() > 0) {
               contents.append(" ")
                       .append(request.getReader().lines().collect(Collectors.joining()))
                       .append(timestamp);
           }
   
           return contents.toString();
       }
   
       private String buildUrlSignatureContent(HttpServletRequest request, String timestamp) {
           Map<String, List<String>> parameterMap = new TreeMap<>();
   
           request.getParameterMap().forEach((key, values) -> {
               if (!QUERY_KEY_SIGNATURE.equals(key)) {
                   parameterMap.put(key, Arrays.asList(values));
               }
           });
   
           if (!parameterMap.containsKey(QUERY_KEY_TIMESTAMP)) {
               parameterMap.put(QUERY_KEY_TIMESTAMP, Collections.singletonList(timestamp));
           }
   
           return parameterMap.entrySet().stream()
                   .flatMap(entry -> entry.getValue().stream()
                           .map(value -> entry.getKey() + "=" + value))
                   .sorted()
                   .collect(Collectors.joining("&"));
       }
   
       private void checkSignatureBaseFields(String timestamp, String signature) throws VerifySignatureException {
           if (timestamp.isEmpty()) {
               throw new VerifySignatureException("Missing timestamp");
           }
           if (signature.isEmpty()) {
               throw new VerifySignatureException("Missing signature");
           }
           if (!isTimestampValid(timestamp)) {
               throw new VerifySignatureException("Timestamp is invalid");
           }
       }
   
       private boolean isTimestampValid(String timestamp) {
           long timestampMilli = Long.parseLong(timestamp);
           long currentTimeMilli = System.currentTimeMillis();
           return timestampMilli > 0 && (currentTimeMilli - timestampMilli) <= TIMESTAMP_EXPIRED_TIME;
       }
   
       private boolean isUrlDigest(String method) {
           return method.isEmpty() || method.equals("GET") || method.equals("DELETE");
       }
   
       private boolean compareSignature(String signature, String contents) {
           String calculatedSignature = new HmacUtils(HmacAlgorithms.HMAC_SHA_256, secret).hmacHex(contents);
   
           // log for debug
           logger.warn("Signature: contents={}, signature={}, hash={}, secret={}",
                   contents, signature, calculatedSignature, secret);
   
           return calculatedSignature.equals(signature);
       }
   
       private static class VerifySignatureException extends Exception {
           public VerifySignatureException(String message) {
               super(message);
           }
       }
   }
   ```


## PHP

1. 签名算法

   ```php
   <?php
   declare(strict_types=1);
   
   function sign(string $secret, string $contents): string {
       return hash_hmac('sha256', $contents, $secret);
   }
   ```

2. 验证签名示例

   > 以下示例代码基于 [Laravel][Laravel] 框架，当然它也适用于 [Symfony][Symfony] 框架。
   >
   > **为了您的数据安全，请不要直接将以下代码用于生产环境，以免造成不必要的损失。**

   ```php
   <?php
   declare(strict_types=1);
   
   namespace App\Http\Controllers;
   
   use Exception;
   use Illuminate\Http\JsonResponse;
   use Illuminate\Http\Request;
   use Illuminate\Support\Facades\Log;
   use Symfony\Component\HttpFoundation\InputBag;
   
   class VerifySignatureException extends Exception
   {
   }
   
   class WebhookController extends Controller
   {
       private const HEADER_TIMESTAMP_KEY = 'X-Meowflow-Timestamp';
       private const HEADER_SIGNATURE_KEY = 'X-Meowflow-Signature';
       private const QUERY_KEY_TIMESTAMP = 'meowflow_timestamp';
       private const QUERY_KEY_SIGNATURE = 'meowflow_signature';
       private const TIMESTAMP_EXPIRED_TIME = 300000; // 5 minutes
   
       /**
        * TODO:: need to replace with your app secret key from your Meowflow app
        *
        * @var string your app secret
        */
       private string $secret = 'your app secret';
   
       public function handle(Request $request): JsonResponse
       {
           try {
               $this->verifySignature($request);
           } catch (VerifySignatureException $e) {
               return response()->json(['message' => $e->getMessage()], 403);
           } catch (Exception $e) {
               Log::error('Unknown error: ' . $e->getMessage(), ['trace' => $e->getTraceAsString()]);
               return response()->json(['message' => 'Internal server error'], 500);
           }
   
           // TODO:: do something with the request here...
           Log::info('----------- received signature request -----------');
           return response()->json(['message' => 'OK']);
       }
   
       /**
        * @throws VerifySignatureException
        */
       private function verifySignature(Request $request): void
       {
           [$timestamp, $signature] = $this->getSignatureFields($request);
           $this->checkSignatureBaseFields($timestamp, $signature);
   
           $contents = $this->buildSignatureContents($request, $timestamp);
           if (!$this->compareSignature($signature, $contents)) {
               throw new VerifySignatureException('Signature verification failed');
           }
       }
   
       /**
        * @param Request $request
        * @return array<string>
        */
       private function getSignatureFields(Request $request): array
       {
           if ($this->isUrlDigest($request->getMethod())) {
               $timestamp = $request->query->getString(self::QUERY_KEY_TIMESTAMP, $request->headers->get(self::HEADER_TIMESTAMP_KEY));
               $signature = $request->query->getString(self::QUERY_KEY_SIGNATURE, $request->headers->get(self::HEADER_SIGNATURE_KEY));
           } else {
               $timestamp = $request->headers->get(self::HEADER_TIMESTAMP_KEY);
               $signature = $request->headers->get(self::HEADER_SIGNATURE_KEY);
           }
   
           return [
               $timestamp ?? '',
               $signature ?? ''
           ];
       }
   
       private function buildSignatureContents(Request $request, string $timestamp): string
       {
           $method = $request->getMethod();
           $contents = $method . ' ' . $request->getHttpHost() . $request->getPathInfo();
   
           if ($this->isUrlDigest($method)) {
               $contents .= '?' . $this->buildUrlSignatureContent($request->query, $timestamp);
           } else {
               $contents .= ' ' . $request->getContent() . $timestamp;
           }
   
           return $contents;
       }
   
       private function buildUrlSignatureContent(InputBag $query, string $timestamp): string
       {
           $params = [];
           foreach ($query as $key => $value) {
               if ($key !== self::QUERY_KEY_SIGNATURE) {
                   $params[$key] = is_array($value) ? implode(',', $value) : (string)$value;
               }
           }
           $params[self::QUERY_KEY_TIMESTAMP] ??= $timestamp;
   
           ksort($params);
           return http_build_query($params);
       }
   
       private function checkSignatureBaseFields(string $timestamp, string $signature): void
       {
           if (empty($timestamp)) {
               throw new VerifySignatureException('Missing timestamp');
           }
           if (empty($signature)) {
               throw new VerifySignatureException('Missing signature');
           }
           if (!$this->isTimestampValid($timestamp)) {
               throw new VerifySignatureException('Timestamp is invalid');
           }
       }
   
       private function isTimestampValid(string $timestamp): bool
       {
           $timestampMilli = (int)$timestamp;
           $currentTimeMilli = (int)(microtime(true) * 1000);
           return $timestampMilli > 0 && ($currentTimeMilli - $timestampMilli) <= self::TIMESTAMP_EXPIRED_TIME;
       }
   
       private function isUrlDigest(string $method): bool
       {
           return empty($method) || $method === 'GET' || $method === 'DELETE';
       }
   
       private function compareSignature(string $signature, string $contents): bool
       {
           $calculatedSignature = hash_hmac('sha256', $contents, $this->secret);
   
           // log for debug
           Log::warning('Signature: ', [
               'contents' => $contents,
               'signature' => $signature,
               'hash' => $calculatedSignature,
               'secret' => $this->secret
           ]);
   
           return hash_equals($calculatedSignature, $signature);
       }
   }
   ```

## Python

1. 签名算法

   ```python
   import hmac
   import hashlib
   
   def sign(secret: str, contents: str) -> str:
       return hmac.new(secret.encode(), contents.encode(), hashlib.sha256).hexdigest()
   ```

2. 验证签名示例

   > 以下示例代码基于 [Flask][Flask] 框架。
   >
   > **为了您的数据安全，请不要直接将以下代码用于生产环境，以免造成不必要的损失。**

   ```python
   import hmac
   import hashlib
   import time
   
   from flask import Flask, request, jsonify
   from typing import Tuple
   
   app = Flask(__name__)
   
   
   class VerifySignatureException(Exception):
       pass
   
   
   class WebhookController:
       HEADER_TIMESTAMP_KEY = 'X-Meowflow-Timestamp'
       HEADER_SIGNATURE_KEY = 'X-Meowflow-Signature'
       QUERY_KEY_TIMESTAMP = 'meowflow_timestamp'
       QUERY_KEY_SIGNATURE = 'meowflow_signature'
       TIMESTAMP_EXPIRED_TIME = 300000  # 5 minutes
   
       def __init__(self):
           # TODO:: need to replace with your app secret key from your Meowflow app
           self.secret = 'your app secret'
   
       @staticmethod
       @app.route('/api/webhook', methods=['GET', 'POST', 'PUT', 'PATCH', 'DELETE'])
       def handle():
           controller = WebhookController()
           try:
               controller.verify_signature()
           except VerifySignatureException as e:
               return jsonify({'message': str(e)}), 403
           except Exception as e:
               app.logger.error(f'Unknown error: {str(e)}')
               return jsonify({'message': 'Internal server error'}), 500
   
           # TODO:: do something with the request here...
           app.logger.warning('----------- received signature request -----------')
           return jsonify({'message': 'OK'})
   
       def verify_signature(self) -> None:
           timestamp, signature = self.get_signature_fields()
           self.check_signature_base_fields(timestamp, signature)
           contents = self.build_signature_contents(timestamp)
           if not self.compare_signature(signature, contents):
               raise VerifySignatureException('Signature verification failed')
   
       def get_signature_fields(self) -> Tuple[str, str]:
           if self.is_url_digest(request.method):
               timestamp = request.args.get(self.QUERY_KEY_TIMESTAMP) or request.headers.get(self.HEADER_TIMESTAMP_KEY, '')
               signature = request.args.get(self.QUERY_KEY_SIGNATURE) or request.headers.get(self.HEADER_SIGNATURE_KEY, '')
           else:
               timestamp = request.headers.get(self.HEADER_TIMESTAMP_KEY, '')
               signature = request.headers.get(self.HEADER_SIGNATURE_KEY, '')
           return timestamp, signature
   
       def build_signature_contents(self, timestamp: str) -> str:
           method = request.method
           contents = f"{method} {request.host}{request.path}"
           if self.is_url_digest(method):
               query_params = self.build_url_signature_content(timestamp)
               contents += f"?{query_params}"
           elif request.data:
               contents += f" {request.data.decode('utf-8')}{timestamp}"
           return contents
   
       def build_url_signature_content(self, timestamp: str) -> str:
           params = {k: v for k, v in request.args.lists() if k != self.QUERY_KEY_SIGNATURE}
           if self.QUERY_KEY_TIMESTAMP not in params:
               params[self.QUERY_KEY_TIMESTAMP] = [timestamp]
           params = {k: ','.join(v) for k, v in params.items()}
   
           return '&'.join(f"{k}={v}" for k, v in sorted(params.items()))
   
       def check_signature_base_fields(self, timestamp: str, signature: str) -> None:
           if not timestamp:
               raise VerifySignatureException('Missing timestamp')
           if not signature:
               raise VerifySignatureException('Missing signature')
           if not self.is_timestamp_valid(timestamp):
               raise VerifySignatureException('Timestamp is invalid')
   
       def is_timestamp_valid(self, timestamp: str) -> bool:
           timestamp_milli = int(timestamp)
           current_time_milli = int(time.time() * 1000)
           return timestamp_milli > 0 and (current_time_milli - timestamp_milli) <= self.TIMESTAMP_EXPIRED_TIME
   
       @staticmethod
       def is_url_digest(method: str) -> bool:
           return not method or method in ['GET', 'DELETE']
   
       def compare_signature(self, signature: str, contents: str) -> bool:
           expected_signature = hmac.new(self.secret.encode(), contents.encode(), hashlib.sha256).hexdigest()
   
           # log for debug
           app.logger.warning('Signature: contents=%s, signature=%s, hash=%s, secret=%s',
                              contents, signature, expected_signature, self.secret
                              )
   
           return hmac.compare_digest(expected_signature, signature)
   
   
   if __name__ == '__main__':
       app.run(debug=True)
   
   ```


## Go

1. 签名算法

   ```go
   package main
   
   import (
   	"crypto/hmac"
   	"crypto/sha256"
   	"encoding/hex"
    )
   
   func Sign(secret, contents string) string {
       h := hmac.New(sha256.New, []byte(secret))
       h.Write([]byte(contents))
       return hex.EncodeToString(h.Sum(nil))
   }
   ```

2. 验证签名示例

   > 以下示例代码基于标准库 `net/http` 实现。
   >
   > **为了您的数据安全，请不要直接将以下代码用于生产环境，以免造成不必要的损失。**

   ```go
   package main
   
   import (
       "bytes"
       "crypto/hmac"
       "crypto/sha256"
       "encoding/hex"
       "errors"
       "fmt"
       "io"
       "log"
       "log/slog"
       "net/http"
       "net/url"
       "slices"
       "strconv"
       "strings"
       "time"
   )
   
   const (
       headerTimestampKey   = "X-Meowflow-Timestamp"
       headerSignatureKey   = "X-Meowflow-Signature"
       queryKeyTimestamp    = "meowflow_timestamp"
       queryKeySignature    = "meowflow_signature"
       timestampExpiredTime = 300000 // 5 minutes
   )
   
   // TODO:: need to replace with your app secret key from your Meowflow app
   var secret = "your app secret"
   
   type verifySignatureError struct {
       message string
   }
   
   func (e *verifySignatureError) Error() string {
       if e == nil {
           return ""
       }
       return e.message
   }
   
   func handleWebhook(w http.ResponseWriter, r *http.Request) {
       if err := verifySignature(r); err != nil {
           var (
               statusCode int
               message    string
           )
           if se := new(verifySignatureError); errors.As(err, &se) {
               message = se.message
               statusCode = http.StatusForbidden
           } else {
               message = "Internal Server Error"
               statusCode = http.StatusInternalServerError
               slog.Error(fmt.Sprintf("Unknown error: %+v", err))
           }
           responseJson(w, statusCode, message)
           return
       }
   
       // TODO:: do something with the request here...
       slog.Info("----------- received signature request -----------")
       responseJson(w, http.StatusOK, "OK")
   }
   
   func responseJson(w http.ResponseWriter, statusCode int, message string) {
       w.Header().Set("Content-Type", "application/json; charset=utf-8")
       w.WriteHeader(statusCode)
       w.Write([]byte(fmt.Sprintf(`{"message":"%s"}`, message)))
   }
   
   func verifySignature(r *http.Request) error {
       timestamp, signature := getSignatureFields(r)
       if err := checkSignatureBaseFields(timestamp, signature); err != nil {
           return err
       }
   
       contents := buildSignatureContents(r, timestamp)
       if !compareSignature([]byte(signature), contents) {
           return &verifySignatureError{message: "signature verification failed"}
       }
       return nil
   }
   
   func getSignatureFields(r *http.Request) (timestamp string, signature string) {
       if isURLDigest(r.Method) {
           timestamp = r.URL.Query().Get(queryKeyTimestamp)
           if timestamp == "" {
               timestamp = r.Header.Get(headerTimestampKey)
           }
           signature = r.URL.Query().Get(queryKeySignature)
           if signature == "" {
               signature = r.Header.Get(headerSignatureKey)
           }
           return timestamp, signature
       }
       return r.Header.Get(headerTimestampKey), r.Header.Get(headerSignatureKey)
   }
   
   func buildSignatureContents(r *http.Request, timestamp string) []byte {
       var buf bytes.Buffer
       buf.WriteString(r.Method)
       buf.WriteString(" ")
       if r.URL.Host != "" {
           buf.WriteString(r.URL.Host)
       } else {
           buf.WriteString(r.Host)
       }
       path := r.URL.Path
       if path == "" {
           path = "/"
       } else if !strings.HasPrefix(path, "/") {
           path = "/" + path
       }
       buf.WriteString(path)
   
       if isURLDigest(r.Method) {
           b := buildURLSignatureContent(r.URL.Query(), timestamp)
           buf.WriteString("?")
           buf.Write(b)
       } else {
           bodyBytes, _ := io.ReadAll(r.Body)
           r.Body = io.NopCloser(bytes.NewBuffer(bodyBytes)) // reset body
           buf.WriteString(" ")
           buf.Write(bodyBytes)
           buf.WriteString(timestamp)
       }
       return buf.Bytes()
   }
   
   func buildURLSignatureContent(query url.Values, timestamp string) []byte {
       params := make(url.Values)
       for key, values := range query {
           if key != queryKeySignature {
               params[key] = values
           }
       }
   
       if !params.Has(queryKeyTimestamp) {
           params.Set(queryKeyTimestamp, timestamp)
       }
   
       keys := make([]string, 0, len(params))
       for k := range params {
           keys = append(keys, k)
       }
       slices.Sort(keys)
       var buf bytes.Buffer
       for _, k := range keys {
           buf.WriteString(k)
           buf.WriteString("=")
           buf.WriteString(strings.Join(params[k], ","))
           buf.WriteString("&")
       }
       if buf.Len() > 0 {
           buf.Truncate(buf.Len() - 1) // remove last "&"
       }
       return buf.Bytes()
   }
   
   func checkSignatureBaseFields(timestamp, signature string) error {
       if timestamp == "" {
           return &verifySignatureError{message: "missing timestamp"}
       }
       if signature == "" {
           return &verifySignatureError{message: "missing signature"}
       }
       if !isTimestampValid(timestamp) {
           return &verifySignatureError{message: "timestamp is invalid"}
       }
       return nil
   }
   
   func isTimestampValid(timestamp string) bool {
       timestampMilli, err := strconv.ParseInt(timestamp, 10, 64)
       if err != nil {
           return false
       }
       currentTimeMilli := time.Now().UnixMilli()
       return timestampMilli > 0 && (currentTimeMilli-timestampMilli) <= timestampExpiredTime
   }
   
   func isURLDigest(method string) bool {
       return method == "" || method == http.MethodGet || method == http.MethodDelete
   }
   
   func compareSignature(signature, contents []byte) bool {
       h := hmac.New(sha256.New, []byte(secret))
       h.Write(contents)
       calculatedSignature := hex.EncodeToString(h.Sum(nil))
   
       // log for debug
       slog.Warn(fmt.Sprintf("Signature: contents=%s, signature=%s, hash=%s, secret=%s",
           contents, signature, calculatedSignature, secret))
   
       return hmac.Equal([]byte(calculatedSignature), signature)
   }
   
   func main() {
       http.HandleFunc("/api/webhook", handleWebhook)
       slog.Info("Server is running on http://127.0.0.1:8080")
       log.Fatalln(http.ListenAndServe(":8080", nil))
   }
   ```


## JavaScript / TypeScript

1. 签名算法

    1. require CommonJS modules

       ```javascript
       const crypto = require('crypto');
       
       function sign(secret, contents) {
         return crypto.createHmac('sha256', secret).update(contents).digest('hex');
       }
       ```

    2. import ES6 modules

       ```typescript
       import {createHmac} from 'crypto';
       
       export function sign(secret: string, contents: string): string {
         return createHmac('sha256', secret).update(contents).digest('hex');
       }
       ```

2. 验证签名示例

   > 以下示例代码基于 [Express][Express] 框架。
   >
   > **为了您的数据安全，请不要直接将以下代码用于生产环境，以免造成不必要的损失。**

   ```typescript
   import {Request, Response} from 'express';
   import crypto from 'crypto';
   import {ParsedQs} from "qs";
   
   class VerifySignatureError extends Error {
       constructor(message: string) {
           super(message);
           this.name = 'VerifySignatureError';
       }
   }
   
   export class WebhookController {
       private static readonly HEADER_TIMESTAMP_KEY = 'X-Meowflow-Timestamp';
       private static readonly HEADER_SIGNATURE_KEY = 'X-Meowflow-Signature';
       private static readonly QUERY_KEY_TIMESTAMP = 'meowflow_timestamp';
       private static readonly QUERY_KEY_SIGNATURE = 'meowflow_signature';
       private static readonly TIMESTAMP_EXPIRED_TIME = 300000; // 5 minutes
   
   
       /**
        * TODO:: need to replace with your app secret key from your Meowflow app
        *
        * @var string your app secret
        */
       private readonly secret: string = 'your app secret';
   
   
       public async handle(req: Request, res: Response): Promise<Response> {
           try {
               await this.verifySignature(req);
           } catch (e) {
               if (e instanceof VerifySignatureError) {
                   return res.status(403).json({message: e.message});
               }
               console.error('Unknown error: ', e);
               return res.status(500).json({message: 'Internal server error'});
           }
   
           // TODO:: do something with the request here...
           console.log('----------- received signature request -----------');
           return res.json({message: 'OK'});
       }
   
       private async verifySignature(req: Request): Promise<void> {
           const {timestamp, signature} = this.getSignatureFields(req);
           this.checkSignatureBaseFields(timestamp, signature);
   
           const contents = this.buildSignatureContents(req, timestamp);
           if (!this.compareSignature(signature, contents)) {
               throw new VerifySignatureError("Signature verification failed");
           }
       }
   
       private getSignatureFields(req: Request): { timestamp: string; signature: string } {
           let timestamp: string | undefined;
           let signature: string | undefined;
   
           if (this.isUrlDigest(req.method)) {
               timestamp = (req.query[WebhookController.QUERY_KEY_TIMESTAMP] as string) || req.header(WebhookController.HEADER_TIMESTAMP_KEY);
               signature = (req.query[WebhookController.QUERY_KEY_SIGNATURE] as string) || req.header(WebhookController.HEADER_SIGNATURE_KEY);
           } else {
               timestamp = req.header(WebhookController.HEADER_TIMESTAMP_KEY);
               signature = req.header(WebhookController.HEADER_SIGNATURE_KEY);
           }
   
           return {
               timestamp: timestamp || '',
               signature: signature || ''
           };
       }
   
       private buildSignatureContents(req: Request, timestamp: string): string {
           const {method, path, query} = req;
           const host = req.header('host') || '';
           let contents = `${method} ${host}${path}`;
   
           if (this.isUrlDigest(method)) {
               const queryParams = this.buildUrlSignatureContent(query, timestamp);
               contents += `?${queryParams}`;
           } else {
               const rawBody = (req as any).rawBody;
               if (rawBody) {
                   contents += ` ${rawBody.toString()}${timestamp}`;
               } else {
                   contents += ` ${timestamp}`;
               }
           }
   
           return contents;
       }
   
       private buildUrlSignatureContent(query: ParsedQs, timestamp: string): string {
           const params: Record<string, string> = Object.fromEntries(
               Object.entries(query)
                   .filter(([key]) => key !== WebhookController.QUERY_KEY_SIGNATURE)
                   .map(([key, value]) => [
                       key,
                       Array.isArray(value) ? value.join(',') : String(value)
                   ])
           );
   
           params[WebhookController.QUERY_KEY_TIMESTAMP] ??= timestamp;
   
           const sortedParams = Object.fromEntries(
               Object.entries(params).sort(([a], [b]) => a.localeCompare(b))
           );
   
           return new URLSearchParams(sortedParams).toString();
       }
   
       private checkSignatureBaseFields(timestamp: string, signature: string): void {
           if (!timestamp) {
               throw new VerifySignatureError("Missing timestamp");
           }
           if (!signature) {
               throw new VerifySignatureError("Missing signature");
           }
           if (!this.isTimestampValid(timestamp)) {
               throw new VerifySignatureError("Timestamp is invalid");
           }
       }
   
       private isTimestampValid(timestamp: string): boolean {
           const timestampMilli = parseInt(timestamp, 10);
           return !isNaN(timestampMilli) && timestampMilli > 0 &&
               (Date.now() - timestampMilli) <= WebhookController.TIMESTAMP_EXPIRED_TIME;
       }
   
       private isUrlDigest(method?: string): boolean {
           return !method || method === 'GET' || method === 'DELETE';
       }
   
       private compareSignature(signature: string, contents: string): boolean {
           const expectedSignature = crypto.createHmac('sha256', this.secret).update(contents).digest('hex')
   
           // log for debug
           console.log('Signature: ', {
               contents: contents,
               signature: signature,
               hash: expectedSignature,
               secret: this.secret
           });
   
           return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature));
       }
   }
   ```

   在 [Express][Express] 框架中，您可能需要使用 `body-parser` 中间件来获取请求体的原始内容。在您的 `app.ts` 中应该添加类似如下的代码：

   ```typescript
   import express from 'express';
   
   const app = express();
    
   // Capture the original request body as a Buffer.
   app.use(express.raw({ type: '*/*' }));
   
   // Parse the request body as JSON.
   app.use(express.json());
   
   // Maybe you need to parse more body types here...
   
   // After the original request body is parsed, save it to req.rawBody.
   app.use((req, res, next) => {
      if (req.body instanceof Buffer) {
          (req as any).rawBody = req.body;
      }
      next();
   });
   ```

[hmac]: https://en.wikipedia.org/wiki/HMAC

[sha-2]: https://en.wikipedia.org/wiki/SHA-2

[Spring Boot]: https://spring.io/projects/spring-boot "Spring Boot"

[Laravel]: https://laravel.com/ "Laravel"

[Symfony]: https://symfony.com/ "Symfony"

[Flask]: https://flask.palletsprojects.com/ "Flask"

[Express]: https://expressjs.com/ "Express"

